# 결제 시스템 성능, 부하, 스트레스 테스트

안녕하세요. 우아한형제들에서 결제시스템을 개발하고 있는 권용근입니다. 입사한지 4개월만에, 드디어 우아한형제들 기술블로그에 글을 남기게 되어 감회가 새롭습니다.

저는 최근 `결제 시스템`의 개비를 진행하며 경험한 `성능, 부하, 스트레스 테스트` 경험을 작성해보려고 합니다.

## 공포의 시작

입사하고 보니 저에게는 `결제 API 단순화`, `결제 시스템 데이터베이스 분리 및 파티션 도입`, `비동기 결제 시스템 개발` 이라는 굵직굵직한 작업들이 기다리고 있었습니다.

완전 새로 경험하는 도메인에 대한 이해는 코드를 이해하는 것과는 완전히 달랐습니다. 결제 시스템이란 도메인은 생각 이상으로 거대했고, 모든 걸 파악하다가는 한 해가 지날 수도 있겠다고 생각했습니다.

그래서 대략적인 도메인을 파악한 후 개발을 하며 파악하고 이해해보기로 했습니다.

### 가시적 영역

`Java`, `Spring Framework`, `ORM` 등의 기술 지식은 그간 해온게 있기 때문에 (구글링이 있기 때문에) 파악하는데 어렵지 않았습니다.

그럼에도 이 프로젝트에서 기능을 수정, 작성하는 것을 두렵게 생각했던 것은

- 도메인, 정책이 완전히 파악되지 않음.
- 거대 규모 프로젝트에서 내가 수정한 코드가 어떤 사이드 이펙트를 발생시킬지 모름.

위 두 가지 이유였습니다.

**하지만!** 기능의 수정, 작성이 `가시적 영역`이 된 이유는 바로 **테스트 코드** 때문입니다.

팀원들이 열심히 작성해 놓은 테스트 코드가 있었기에, 테스트 코드를 통해 정책이 파악되기도 하며, 테스트 코드의 보호 아래 저는 부담없이 코드를 작성해나갈 수 있었습니다.

> *새로 맞이할 혹은 같이 협업하는 동료, 그리고 미래의 나를 위해 테스트 코드를 작성합시다!*

### 미지의 영역

대부분의 기능의 개발이 완료되었습니다. 이때부터 본격적인 미지의 영역에 대한 공포가 시작되었습니다.

![모르는 것에 대한 공포](./images/dark.png)

**내가 만든 이 시스템은 실제 장비에서**

- 어느 정도의 **부하** 를 견딜 수 있는가?
- 시스템(데이터베이스, 서버), 자원(cpu, disk, memory 등)에서 **병목** 이 생기진 않는가?
- 자원을 **효율적** 으로 사용하는가?
- **메모리 누수, 오류, 오버플로우** 는 발생하지 않는가?
- **최악의 상황** 에선 어떤 동작을 하는가? (예측하고 대비하기 위하여)
- **장애 조치와 복구** 가 잘 동작을 하는가?


전혀 감이 안잡혔습니다. 이것은 흔히 말하는 `localhost:8080` 레벨에서는 확인할 수 없는 문제였습니다.

위의 수많은 공포에 대하여, 그저 '내가 정의해놓은데로, 작성해놓은데로 잘 동작하겠지'라고 믿을 수는 없었습니다. 실제 사용자의 돈이 움직이는 결제 시스템에서 전혀 보이지 않는 불안요소를 가지고 가기에는 너무나 두렵고 무서웠습니다.

그래서 코드 레벨에서 테스트 코드가 두려움을 해소해줬 듯, 이번에도 두려움을 해소시켜줄 성능 테스트 환경을 만들게 되었습니다.

## 테스트 환경

### 외부 인터페이스 Mock 처리

결제 시스템은 사용자의 주문 비용을 각종 결제수단(`PG사`, `포인트`, `쿠폰`) 등의 시스템과 통신하여 지불처리하는 시스템입니다. 많은 부분을 생략하고 간단하게만 표현하면, 하나의 결제는 `결제수단` 시스템이란 외부 인터페이스를 거치게 됩니다.

![결제 시스템 간단히](./images/billing.png)

그래서 저는 `결제수단` 시스템을 Mock 처리해야 했습니다. 온전히 테스트 대상 시스템의 성능을 측정하기 위해서 외부 시스템은 항상 기대한 결과만을 반환하는 환경이 필요하기 때문입니다.

#### 하지 말아야할 Mocking 방식

**1. `Spring Profile` 을 사용하여 `RestOpertation` 을 Mocking**

이 방식은 테스트 코드를 작성할 때 가장 많이 사용하는 방식인 객체 Mocking 방식입니다. 로직에 대한 검증을 하는 테스트와 달리, 성능 테스트는 어플리케이션 동작과 자원의 사용을 모두 보아야만 하는 테스트입니다.

`객체 Mocking` 은 해당 객체의 행위 뒤로 들어가야 할 Call Stack을 무시해버리게 됩니다. 외부 인터페이스를 Mocking 하는 것 처럼 보이지만, 내부 인터페이스도 Mocking 해버리는 `객체 Mocking` 은 성능 테스트에서 피해야합니다.

**2. 같은 어플리케이션에 Dummy Controller 생성**

이 방식도 아주 간혹 테스트 코드를 작성할 때 사용하는 방식입니다. 이 방식이 1번 방식과 다른 것은 실제로 요청을 보내고 받으며 자원을 사용한다는 것 입니다.

그러나 `Dummy Controller` 의 로직은 테스트 시스템의 자원과 리소를 같이 사용해버리게 됩니다. 테스트 대상 시스템이 더 늘어나 버리는 신뢰성이 굉장히 떨어지는 의미없는 성능 테스트를 하게 됩니다. **테스트를 위한 무언가가 테스트 대상 시스템에게 절대로 어떠한 영향도 미쳐서는 안됩니다.**

#### Mock Server 만들고 띄우기

그래서 우리는 테스트 대상 시스템과 완벽히 분리된 **Mock Server** 를 띄워야 합니다.

외부 인터페이스 Mock이 갖추어야 할 조건을 아래와 같이 정의했습니다.

- 모든 요청에 기대한 결과만을 반환한다.
- 모든 요청에 기대한 퍼포먼스만 낸다.
- 병목이 되지 않아야 한다.

제가 만든 것은 가짜 PG사인 `Gazua PAY` 입니다. 요청 인터페이스는 기대한 결과와 퍼포먼스로 응답을 하도록 하는 값을 받도록 하였습니다.

![Gazua Pay](./images/gazua.png)
*(개발 당시에는 코인 시장이 엄청 핫할 때 였습니다. 승인 결과의 message는 그래프의 상승을 표현했는데 아무도 눈치채지 못했습니다.)*

저는 Spring 쟁이라 `Spring Boot`로 아주 간단히 모든 요청에 기대한 결과, 퍼포먼스를 내는 Mock Application을 만들었습니다.

제가 이 어플리케이션을 띄우는데 사용한 것은 `AWS Elastic Beanstalk` 입니다. (우아한형제들은 `AWS` 사용을 적극 지원해주기 때문에!)

![Elastic Beanstalk](./images/beanstalk.png)
*(Elastic Beanstalk 홍보 영상 중..)*

`Elastic Beanstalk` 은 애플리케이션을 업로드하기만 하면 용량 프로비저닝, 로드 밸런싱, Auto Scaling, 애플리케이션 상태 모니터링에 대한 배포 정보를 자동으로 처리해줍니다.

`Mock Server` 에 병목이 생기면 `Scale Out` 을 클릭만으로 바로 실행시킬 수 있습니다.

이제 모든 요청에 **기대한 결과와 포퍼먼스를 반환하는 병목이 되지 않는 Mock Server** 를 띄웠습니다.

### 사용한 도구들

#### 1. nGrinder

![nGrinder](./images/ngrinder.png)

`nGrinder` 는 성능 측정 목적으로 개발 된 오픈소스 프로젝트로

- 테스트 프로세스를 제공
- 부하를 줄 수 있는 웹 인터페이스를 제공
- 테스트 결과를 수집하여 통계로 제공

등의 기능을 제공합니다.

성능 측정 도구로 `nGrinder` 가 가장 좋았던 것은 `groovy` 스크립트로 테스트 시나리오를 작성할 수 있다는 것 이였습니다. `groovy`는 `gradle`, `jenkins file`, `spock` 등에서 자주 다루었던 친숙한 언어였기에 내가 원하는 테스트 시나리오를 쉽고 자유롭게 작성할 수 있었습니다.

#### 2. pinpoint

![pinpoint](./images/pinpoint.png)

`pinpoint` 는 Java로 작성된 대규모 분산 시스템 용 APM 도구입니다.

사내에서 사용하고 있는 모니터링툴이기도 하며, `Transaction Map` 과 `Stack Trace` 을 제공하는 APM 중 하나입니다.

##### Transaction Map

테스트의 상태를 실시간으로 확인할 수 있는 `Transaction Map` 기능은

빠르게 이상을 감지하도록 합니다. `nGrinder` 의 테스트 단위의 그래프보다 직접적으로 이상 패턴을 통해 문제를 인식할 수 있게 해줍니다.

실제로 테스트를 하며 수많은 이상 패턴들이 탄생하기도 하였습니다.

![기영이 패턴](./images/gy.png)
*(기영이 패턴)*

![롯데타워 패턴](./images/lt.png)
*(L타워 패턴)*

![백설기 패턴](./images/bsg.png)
*(노력 끝에 얻어진 백설기 패턴)*

그리고 `Transaction` 의 `Stack Trace` 기록 기능으로, 어플리케이션의 직접적인 병목이나 문제를 빠르게 찾을 수 있습니다.

#### 3. jstack

`pinpoint` 로 어플리케이션의 전반적인 상황을 파악할 수 있었지만, `pinpoint` 의 Trace 기능으로 **모든 패키지와 클래스를 탐색** 하는 것은 너무 과하며, **Thread 간의 경합** 으로 발생되는 예기치 않은 현상들을 탐지하기는 어렵습니다.

이럴 때 우리는 `Thread Dump` 를 분석해야 합니다. 저는 JVM 의 내장 명령 도구인 `jstack` 을 사용하여 쉽게 `Thread Dump` 를 획득할 수 있었습니다.

![JSTACK](./images/jstack.png)

##### 4. dstat

우리가 만드는 시스템은 결국 하드웨어 위에서 동작하게 되고, 시스템의 리소스 자원 사용은 `Scale Up`, `Scale Out`, `Scale Down` 의 중요한 지표가 됩니다.

그러므로 우리는 테스트를 통해 이 시스템은 리소스 자원을 최대한으로 사용하고 있다 라는 결론으로 도달해야 합니다.

저는 리소스 자원을 실시간으로 모니터링할 때 `dstat` 을 사용하였습니다.

`dstat` 은 vmstat, iostat, ifstat, netstat 정보 등을 결합한 내용을 보여주고, 실시간성 통계를 제공해주어 성능 테스트 중 모니터링하기에 매우 적합했습니다.

`dstat` 하나의 명령어로 대부분의 리소스를 모니터링할 수 있었습니다.

![dstat](./images/dstat.png)

> dstat으로 모니터링 가능한 자원 : aio, cpu, cpu24, disk, disk24, disk24old, epoch, fs, int, int24, io, ipc, load, lock,
        mem, net, page, page24, proc, raw, socket, swap, swapold, sys, tcp, time, udp, unix,
        vm

#### 5. kingpoint

`kingpoint` 라는 도구를 아시나요? 제가 만든 것이라 당연히 모를 것 입니다. 비동기 어플리케이션의 완벽한 모니터링이 아직은 어렵기도 하며, 어플리케이션의 특성을 반영한 모니터링을 하기에도 쉽지 않았습니다.

정말 보아야 하는 것이 있는데 그것을 지원하는 도구가 없다면, **테스트를 위한 무언가가 실제 어플리케이션의 성능에 절대 영향을 주지 않는다는 것을 꼭 지키는 선에서** 만들어보는 것도 나쁘지 않을 것 같습니다.

비동기 대한 모니터링을 위해 요청과 완료 시점에 특정 key 값으로 통계를 전송하도록 하여, 분석한 지표를 chart.js 로 그려주는 간단한 모니터링 툴 입니다. 저는 이로인해 많은 두려움을 해소할 수 있었습니다.

![kingpoint](./images/kingpoint.png)

## 진행했던 테스트

![어둠을 밝혀보자](./images/light.png)

그래서 저는 아래와 같은 테스트들을 진행했습니다.

### 성능 테스트

- 실제 트래픽 상황에서의 정상 동작
- 기존 시스템 대비 BenchMarking

### 부하 테스트

- 리소스 병목 탐색, 어플리케이션 버그 탐색
- 이벤트 상황과 같은 순간 트래픽 최대치, 한계치를 탐색
- 신규 스펙 장비에서 MySql 설정 최적화 탐색

### 스트레스 테스트

- 장기간 부하 발생에 대한 한계치를 탐색 예외 동작 상황 확인
- 무중단 배포를 위한 Graceful Shutdown 정상 동작 확인
- 데이터베이스 failover 상황, 자동 복구, 예외 동작 상황 확인
- 외부 요인(PG사)의 밀릴, 예외 상황 동작 확인

## 마무리

지금까지 `결제 시스템` 개비를 진행하며 경험했던 `성능, 부하, 스트레스 테스트` 였습니다. 보았어야 했는데 보지 않았던 것, 더 쉽게 볼 수 있었는데 어렵게 보았던 것 등 많은 시행 착오가 있었지만, 환경을 만들고 테스트를 하면서 많은 자신감을 얻을 수 있었습니다.

그래도 배포 할 땐..

![배포날](./images/deploy.png)

긴글 읽어주셔서 감사합니다.

## 참고

- [성능, 부하, 스트레스 테스트](http://www.softfactory.org/test/performance)
- [Elastic Beanstalk 소개](https://aws.amazon.com/ko/elasticbeanstalk/)
- [pinpoint 소개](https://naver.github.io/pinpoint/)
- [dstat 소개](http://dag.wiee.rs/home-made/dstat/)
